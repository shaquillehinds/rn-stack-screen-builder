var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import j from "jscodeshift";
import { mkdirSync, readFileSync, writeFileSync } from "fs";
import { format } from "prettier";
import chalk from "chalk";
import s from "./stages/index.js";
import f from "./finders/index.js";
import { execSync } from "child_process";
const chalkGold = chalk.rgb(244, 184, 0);
class InjectionPipeline {
    constructor(fileLocation, prettierOptions) {
        this.fileLocation = fileLocation;
        this.prettierOptions = prettierOptions;
        this.asts = [];
        this.newFiles = [];
        this.newDirPaths = [];
        this.updated = [];
        this.created = [];
        this.newDirLogs = [];
        this.updated.push(chalk.bold.cyanBright(`\nUpdating >> ${fileLocation}`));
    }
    get _ast() {
        return this.ast;
    }
    parse(fileLocation) {
        if (fileLocation) {
            if (this.fileLocation === fileLocation) {
                return this;
            }
            this.fileLocation = fileLocation;
            this.updated.push(chalk.bold.cyanBright(`\nUpdating >> ${fileLocation}`));
        }
        const file = readFileSync(this.fileLocation, "utf-8");
        this.ast = j.withParser("tsx")(file);
        this.asts.push({ location: this.fileLocation, ast: this.ast });
        return this;
    }
    stage({ finder, stage, options }) {
        if (!this.ast)
            this.parse();
        if (!options.col)
            options.col = finder.func(j, this.ast, finder.options);
        stage(j, this.ast, options);
        return this;
    }
    finish(filesToOpen) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.asts.length === 0) {
                console.error(chalk.bgRed("You don't have any asts loaded."));
                return this;
            }
            this.newDirPaths.forEach((dir, index) => {
                try {
                    mkdirSync(dir);
                    console.info(this.newDirLogs[index]);
                }
                catch (error) {
                    console.error(`${chalk.bgRed("[Error]")}: ${error}`);
                }
            });
            this.newFiles.forEach((newFile, index) => {
                try {
                    writeFileSync(newFile.location, newFile.content, "utf-8");
                    console.info(this.created[index]);
                }
                catch (error) {
                    console.error(`${chalk.bgRed("[Error]")}: ${error}`);
                }
            });
            for (let ast of this.asts) {
                try {
                    const updatedSource = yield format(ast.ast.toSource(), Object.assign({ parser: "typescript" }, this.prettierOptions));
                    writeFileSync(ast.location, updatedSource, "utf-8");
                }
                catch (error) {
                    console.error(`${chalk.bgRed("[Error]")}: ${error}`);
                }
            }
            const updateString = this.updated.join("\n");
            console.info(updateString);
            if (filesToOpen && filesToOpen.length > 0) {
                filesToOpen.forEach(file => execSync(`code ${file}`));
            }
            this.asts = [];
            this.newFiles = [];
            this.newDirPaths = [];
            this.updated = [];
            this.created = [];
            this.newDirLogs = [];
            return this;
        });
    }
    addLog(log, type = "update") {
        if (type === "update")
            this.updated.push(`${chalkGold("[Update]")}: ${log}`);
        else if (type === "create")
            this.created.push(`${chalk.greenBright("[Create]")}: ${log}`);
        else if (type === "directory")
            this.newDirLogs.push(`${chalk.bold.green("+ [Directory]")}: ${log}`);
    }
    injectDirectory(path) {
        if (!this.ast)
            this.parse();
        this.newDirPaths.push(path);
        this.addLog(path, "directory");
        return this;
    }
    injectFileFromTemplate(options) {
        if (!this.ast)
            this.parse();
        let content = readFileSync(options.templatePath, "utf-8");
        for (let { keyword, replacement } of options.replaceKeywords) {
            content = content.replaceAll(keyword, replacement);
        }
        this.newFiles.push({ content, location: options.newFilePath });
        this.addLog(options.newFilePath, "create");
        return this;
    }
    injectArrayElement(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.arrayVariableFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectArrayElementStage(j, this.ast, newStageOpts);
        this.addLog(`Injected array element to array: ${found.idName}`);
        return this;
    }
    injectTSEnumMember(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.tsEnumFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectTSEnumMemberStage(j, this.ast, newStageOpts);
        this.addLog(`Injected enum member ${stageOptions.key} to enum: ${found.idName}`);
        return this;
    }
    injectTSTypeAliasConditional(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.tsTypeAliasFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectTSTypeAliasConditionalStage(j, this.ast, newStageOpts);
        this.addLog(`Injected type conditional to type alias: ${found.idName}`);
        return this;
    }
    injectProperty(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.objectVariableFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectPropertyStage(j, this.ast, newStageOpts);
        this.addLog(`Injected object property ${stageOptions.key} to: ${found.idName}`);
        return this;
    }
    injectSwitchCase(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.switchFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectSwitchCaseStage(j, this.ast, newStageOpts);
        this.addLog(`Injected switch case ${stageOptions.caseName} to switch statement: ${found.idName}`);
        return this;
    }
    injectTSTypeAlias(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.tsTypeAliasFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectTSTypeAliasStage(j, this.ast, newStageOpts);
        this.addLog(`Injected type alias: ${stageOptions.type}`);
        return this;
    }
    injectTSTypeLiteral(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.tsTypeLiteralFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectTSTypeLiteralStage(j, this.ast, newStageOpts);
        this.addLog(`Injected to type literal: ${found.idName}`);
        return this;
    }
    injectClassMember(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.classBodyFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectClassMemberStage(j, this.ast, newStageOpts);
        this.addLog(`Injected a class member to class: ${found.idName}`);
        return this;
    }
    injectTSInterfaceBody(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.tsInterfaceBodyFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectTSInterfaceBodyStage(j, this.ast, newStageOpts);
        this.addLog(`Injected to interface: ${found.idName}`);
        return this;
    }
    injectJSXElement(stageOptions, finderOpts) {
        if (!this.ast)
            this.parse();
        const found = f.jsxElementFinder(j, this.ast, finderOpts);
        const newStageOpts = Object.assign(Object.assign({}, stageOptions), found);
        s.injectJSXElementStage(j, this.ast, newStageOpts);
        this.addLog(`Injected to jsx element: ${found.idName}`);
        return this;
    }
    injectNamedExportProperty(stageOptions) {
        if (!this.ast)
            this.parse();
        s.injectNamedExportPropertyStage(j, this.ast, Object.assign(Object.assign({}, stageOptions), f.exportFinder(j, this.ast)));
        this.addLog(`Injected export property: ${stageOptions.name}`);
        return this;
    }
    injectImport(stageOptions) {
        if (!this.ast)
            this.parse();
        s.injectImportStage(j, this.ast, Object.assign(Object.assign({}, stageOptions), { col: f.importFinder(j, this.ast) }));
        this.addLog(`Injected${stageOptions.importName ? " default " : " "}import: ${stageOptions.importName}`);
        return this;
    }
    injectStringTemplate(stageOptions) {
        if (!this.ast)
            this.parse();
        stageOptions.col = f.programFinder(j, this.ast);
        s.injectStringTemplateStage(j, this.ast, stageOptions);
        this.addLog(`Injected string template code`);
        return this;
    }
}
export default InjectionPipeline;
