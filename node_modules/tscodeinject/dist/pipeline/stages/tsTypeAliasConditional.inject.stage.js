import stringToASTType from "../parsers/stringToASTType.parser.js";
import { DebugLogger } from "../../utils/Logger.js";
import injectToProgram from "../../utils/injectToProgram.inject.js";
const log = DebugLogger("tsTypeAliasConditional.inject.stage.ts");
/**
 *
 * @param options.trueClause - Provide type signature in a template string
 * @example
 * ```
 * (`
 *   CustomType | "someAlias"
 * `)
 * ```
 */
export default function injectTSTypeAliasConditionalStage(jcs, workingSource, opts) {
    if (!opts.col) {
        log("error", "No expression collection passed to this stage.");
        return workingSource;
    }
    const colSize = opts.col.size();
    const template = `type Template = ${opts.trueClause}`;
    const ast = jcs.withParser("tsx")(template);
    const trueType = ast.find(jcs.TSTypeAliasDeclaration).get().value
        .typeAnnotation;
    const checkType = jcs.tsTypeReference(jcs.identifier(opts.extendee));
    const astType = stringToASTType(opts.extender).type;
    const extendsType = astType.type === "Identifier"
        ? jcs.tsTypeReference(astType)
        : jcs.tsLiteralType(astType);
    let falseType;
    if (opts.falseClause) {
        const template2 = `type Template = ${opts.falseClause}`;
        const ast2 = jcs.withParser("tsx")(template2);
        falseType = ast2.find(jcs.TSTypeAliasDeclaration).get().value
            .typeAnnotation;
    }
    else {
        const conditional = opts.col.find(jcs.TSConditionalType);
        if (conditional.size() !== 0)
            falseType = conditional.get().value;
        else {
            if (colSize !== 0)
                falseType = opts.col.get().value
                    .typeAnnotation;
            falseType = jcs.tsUndefinedKeyword();
        }
    }
    const newConditionalType = jcs.tsConditionalType(checkType, extendsType, trueType, falseType);
    if (colSize === 0) {
        if (!opts.forceInject)
            log("error", `Type alias ${opts.idName} was not found.`);
        let constraint;
        if (opts.constraint)
            constraint = jcs.tsTypeReference(jcs.identifier(opts.constraint));
        injectToProgram(workingSource, [
            {
                statement: jcs.exportNamedDeclaration(jcs.tsTypeAliasDeclaration.from({
                    id: jcs.identifier(opts.idName),
                    typeAnnotation: newConditionalType,
                    typeParameters: jcs.tsTypeParameterDeclaration([
                        jcs.tsTypeParameter("T", constraint)
                    ])
                }))
            }
        ]);
    }
    else {
        const typeAliasIdentifier = opts.col.get().value.id;
        const newTypeAliasDeclaration = jcs.tsTypeAliasDeclaration.from({
            typeParameters: opts.col.get().value.typeParameters,
            id: typeAliasIdentifier,
            typeAnnotation: newConditionalType
        });
        opts.col.replaceWith(newTypeAliasDeclaration);
    }
    return workingSource;
}
