var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import chalk from "chalk";
import { FinderTypeE } from "../../@types/finder.enums.js";
import { DebugLogger } from "../../utils/Logger.js";
import newFinderCommandPipeline from "../pipelines/newFinder.command.pipeline.js";
import newStageCommandPipeline from "../pipelines/newStage.command.pipeline.js";
import newCommandPrompts from "./new.prompts.js";
import utilities, { handleName } from "./new.utilities.js";
const log = DebugLogger("new.command.ts");
export default function newCommand(program) {
    program
        .command("new [type]")
        .description("Creates a new stage or finder")
        // dash syntax resolves to camel case --first-name=firstName
        .option("-n --name <string>", "Name of stage or finder")
        .option("-f --finder <string>", "Name of finder you want to use for the stage")
        .option("-c --collection <string>", "Name of stage collection")
        .action((type, { name: n, collection, finder: f }) => __awaiter(this, void 0, void 0, function* () {
        let newType = type;
        if (!type)
            newType = yield newCommandPrompts.type();
        if (!n)
            n = yield newCommandPrompts.name();
        const [name, nameL] = utilities.handleName(n);
        if (!collection)
            collection = yield newCommandPrompts.collection();
        if (newType === "finder") {
            const finderOpts = yield newCommandPrompts.options("finder");
            yield newFinderCommandPipeline(name, finderOpts, collection);
        }
        else if (newType === "stage") {
            if (!f)
                f = yield newCommandPrompts.finder();
            if (!f) {
                log("error", "A finder is required to create a new stage");
            }
            const [finder, finderL] = handleName(f);
            if (finder && !FinderTypeE[finderL]) {
                console.info(chalk.cyanBright("This finder does not exist, so it will be created"));
                const finderOpts = yield newCommandPrompts.options("finder");
                yield newFinderCommandPipeline(finder, finderOpts, collection);
            }
            const stageOpts = yield newCommandPrompts.options("stage");
            yield newStageCommandPipeline(name, finderL, stageOpts, collection);
        }
        process.exit(0);
    }));
}
